### part1-1 函数式编程

#### 1、为什么要学习函数式编程

函数式编程(Functional Programming, FP) FP 是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程，

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
- 面向过程编程：按照步骤来实现，一步一步实现我们想要的功能。
- 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界(对运算过程进行抽象)。

    - 程序的本质：根据输入通过某种运算获得响应的输出，程序开发过程中会涉及很多有输入和输出的函数。
    - x -> f(联系、映射) -> y, y=f(x)。
    - 函数式编程中的函数指的不是程序中的函数(方法), 而是数学中的函数即映射关系，例如：y=sin(x)，x 和 y 的关系
    - 相同的输入始终要得到相同的输出(纯函数)。
    - 函数式编程用来描述数据(函数)之间的映射。

        - 函数式编程是随着 React 的流行受到越来越多的关注。
        - vue3 也开始拥抱函数式编程。
        - 函数式编程可以抛弃 this。
        - 打包过程中可以更好的利用 tree shaking（是一种通过消除最终文件中未使用的代码来优化体积的方法） 过滤无用代码。
        - 方便测试，方便并行处理。
        - 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda。

#### 2、高阶函数

- 高阶函数(Higher-order function)

    - 可以把函数作为参数传递给另一个函数
    - 可以把函数作为另一个函数的返回结果

- 函数作为参数

```javascript
// filter 
function filter(array, fn) {
  let results = [];
  for (let i = 0; i < array.length; i++) {
    if (fn(array[i])) {
      results.push(array[i])
    }
  }
  return results;
}

let arr = [1, 10, 39, 33, 2, 8, 88];
let r = filter(arr, function (item) {
  return item % 2 === 0;
})
```

- 函数作为返回值
```javascript
// 基本语法
function markFn() {
  let msg = 'Hello Function';
  return function () {
    console.log(msg)
  }
}
markFn()();
```

```javascript
// once  jQ：给一个 DOM 元素注册事件，并且这个事件只会执行一次  lodash: 让这个函数只执行一次
function once (fn) {
  let done = false;
  return function(){
    if(!done) {
      done = true;
      return fn.apply(this, arguments);
    } 
  }
}

let pay = once(function (money) {
  console.log(`支付: ${money} RMB`);
});

pay(100);
pay(100);
pay(100);
pay(100);
pay(100);
```

#### 闭包

- 闭包(Closure): 函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包
    
    - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员
    
- 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，**但是堆上的作用域成员因为被外部引用不能释放，** 因此，内部函数依然可以访问外部函数的成员。

#### 纯函数

- **纯函数：相同的输入永远会得到相同的输出。**

    - 纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y = f(x);
      
    - 好处：可缓存
        
        - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来。
    
- lodash: 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。
- 数组的 slice 和 splice 分别是：纯函数和非纯函数。

    - slice 返回数组中指定部分，不会改变原数组。
    - splice 对数组进行操作返回该数组，会改变原数组。
    
- 函数式编程不会保留计算中间的结果，所以变量是不可变的(无状态的)。
- 我们可以把一个函数的执行结果交给另一个函数去处理。

    - 可测试
        
        - 纯函数让测试更方便。
    
    - 并行处理
    
        - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况。
        - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数(Web Worker)。
    
    - 副作用
    
        - 纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。
    
    - 副作用来源：
    
        - 配置文件
        - 数据库
        - 获取用户的输入
        - ......
    
    所有的外部交互都有可能代理副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制他们在可控范围内发生。
  
#### 柯里化(Haskell Brooks Curry)

- 柯里化(Currying)

    - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）;
    - 然后返回一个新的函数接收剩余的参数，返回结果。
    
#### lodash 中的柯里化函数

- _.curry(func)

    - 功能：创建一个函数，该函数接收一个或多个 func 的参数，如果 func 所需要的参数都被提供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。
    - 参数：需要柯里化的函数；
    - 返回值：柯里化后的函数；
    